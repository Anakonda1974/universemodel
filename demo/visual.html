<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Universe Model Visual</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/leader-line@1.0.7/leader-line.min.js"></script>
  <script src="https://unpkg.com/interactjs/dist/interact.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }
    #workspace {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }
    #canvas {
      position: absolute;
      inset: 0;
      transform-origin: 0 0;
    }
    .bg-grid {
      background-image:
        linear-gradient(#2d2d2d 1px, transparent 1px),
        linear-gradient(90deg, #2d2d2d 1px, transparent 1px);
      background-size: 40px 40px;
    }
    .card { width: 200px; }

    .row:nth-child(odd) { background: #334155; }
    .row:nth-child(even) { background: #1f2937; }

    .port {
      width: 1rem;
      height: 1rem;
      cursor: pointer;
      transition: outline 0.1s ease-in-out;
    }
    .port-hover, .port:hover { outline: 2px solid #fbbf24; }
    .collapsed .row { display: none; }
    .line-handle {
      width: 0.75rem;
      height: 0.75rem;
      background: #22c55e;
      border-radius: 9999px;
      position: absolute;
      cursor: pointer;
    }

    .line-label {
      position: absolute;
      font-size: 0.75rem;
      background: rgba(0,0,0,0.6);
      padding: 0 0.25rem;
      border-radius: 0.25rem;
      pointer-events: none;
      white-space: nowrap;
    }

  </style>
</head>
<body class="bg-black text-white">
  <div id="toolbar" class="absolute z-10 top-2 left-2 space-x-2">
    <button id="resetBtn" class="bg-gray-700 px-2 py-1 rounded">Reset view</button>
    <button id="clearBtn" class="bg-gray-700 px-2 py-1 rounded">Clear connections</button>
  </div>
  <div id="workspace" class="bg-grid">
    <div id="canvas"></div>
  </div>

  <script type="module">
    import { SeedManager } from '../dist/SeedManager.js';
    import { PropertyGraph } from '../dist/PropertyGraph.js';
    import { ProceduralEntity } from '../dist/ProceduralEntity.js';
    import { createPlanetDefinitions } from '../dist/PlanetDefinitions.js';

    const seedManager = new SeedManager('DemoSeed42');
    const graph = new PropertyGraph(createPlanetDefinitions());
    const planet = new ProceduralEntity('Planet-X', ['MilkyWay','System-4','Planet-X'], seedManager, graph);

    const groups = planet.generateGrouped();
    const workspace = document.getElementById('workspace');
    const canvas = document.getElementById('canvas');

    const allPorts = new Map();
    const cards = [];

    let left = 20, top = 20;
    for (const [group, props] of Object.entries(groups)) {
      const card = document.createElement('div');
      card.className = 'card absolute bg-gray-900 p-4 rounded-lg space-y-2';
      card.style.left = left + 'px';
      card.style.top = top + 'px';
      top += 30;
      left += 220;

      const header = document.createElement('div');

      header.className = 'flex justify-between items-center mb-2 cursor-pointer';
      const title = document.createElement('span');
      title.className = 'text-lg underline';
      title.textContent = group;
      const close = document.createElement('button');
      close.textContent = '×';
      close.className = 'text-red-400';
      close.addEventListener('click', () => removeCard(card));
      header.appendChild(title);
      header.appendChild(close);
      header.addEventListener('dblclick', () => card.classList.toggle('collapsed'));

      card.appendChild(header);

      for (const [key, value] of Object.entries(props)) {
        const row = document.createElement('div');
        row.className = 'row flex items-center text-sm mb-1 space-x-1 px-1';
        row.dataset.id = key;

        const inPort = document.createElement('div');
        inPort.className = 'port bg-red-400 rounded-full in-port';
        inPort.id = `in-${key}`;

        inPort.dataset.prop = key;
        row.appendChild(inPort);


        const label = document.createElement('span');
        label.textContent = key + ':';
        row.appendChild(label);

        const valueInput = document.createElement('input');
        valueInput.type = 'text';
        valueInput.value = value;
        valueInput.className = 'value-input bg-gray-700 rounded px-1 text-black w-20';
        row.appendChild(valueInput);


        const outPort = document.createElement('div');
        outPort.className = 'port bg-blue-400 rounded-full out-port';
        outPort.id = `out-${key}`;
        outPort.dataset.prop = key;

        row.appendChild(outPort);


        allPorts.set(outPort.id, outPort);
        allPorts.set(inPort.id, inPort);
        card.appendChild(row);
      }
      canvas.appendChild(card);
      cards.push(card);
    }

    const connections = [];

    function removeConnection(conn) {
      conn.line.remove();

      conn.handle.remove();
      if (conn.label) conn.label.remove();

      connections.splice(connections.indexOf(conn), 1);
    }

    function removeCard(card) {
      const ports = card.querySelectorAll('.port');
      ports.forEach(p => {
        connections.slice().forEach(c => {
          if (c.from === p || c.to === p) removeConnection(c);
        });
      });
      card.remove();
    }


    function addConnection(from, to) {
      const line = new LeaderLine(from, to, {
        color: 'cyan',
        path: 'fluid',
        startPlug: 'square',
        endPlug: 'arrow'
      });

      const handle = document.createElement('div');
      handle.className = 'line-handle';
      workspace.appendChild(handle);

      const label = document.createElement('div');
      label.className = 'line-label';
      label.textContent = `${from.dataset.prop} → ${to.dataset.prop}`;
      workspace.appendChild(label);

      const conn = { line, from, to, handle, label, anchor: null, anchorPos: null };

      function updateHandle() {
        const wsRect = workspace.getBoundingClientRect();
        let x, y;
        if (conn.anchorPos) {
          x = state.x + conn.anchorPos.x * state.scale;
          y = state.y + conn.anchorPos.y * state.scale;
        } else {
          const s = from.getBoundingClientRect();
          const e = to.getBoundingClientRect();
          x = ((s.left + s.right) / 2 + (e.left + e.right) / 2) / 2 - wsRect.left;
          y = ((s.top + s.bottom) / 2 + (e.top + e.bottom) / 2) / 2 - wsRect.top;
        }
        handle.style.left = `${x - handle.offsetWidth / 2}px`;
        handle.style.top = `${y - handle.offsetHeight / 2}px`;

        label.style.left = `${x - label.offsetWidth / 2}px`;
        label.style.top = `${y - 20}px`;
      }

      conn.updateHandle = updateHandle;
      updateHandle();
      line.position();

      const lineElement = line.element || line.path;
      if (lineElement) {
        lineElement.style.pointerEvents = 'stroke';
        lineElement.addEventListener('dblclick', e => {
          const wsRect = workspace.getBoundingClientRect();
          conn.anchorPos = {
            x: (e.clientX - wsRect.left - state.x) / state.scale,
            y: (e.clientY - wsRect.top - state.y) / state.scale
          };
          if (conn.anchor && line.removePointAnchor) {
            line.removePointAnchor(conn.anchor);
          }
          if (line.addPointAnchor && LeaderLine.pointAnchor) {
            conn.anchor = line.addPointAnchor(LeaderLine.pointAnchor({ element: handle }));
          }
          updateHandle();
          line.position();
        });
      }

      handle.addEventListener('dblclick', () => removeConnection(conn));

      connections.push(conn);
      return conn;
    }


    for (const def of graph.getDefinitions()) {
      const deps = def.inputs || [];
      for (const dep of deps) {
        const from = document.getElementById('out-' + dep);
        const to = document.getElementById('in-' + def.id);
        if (from && to) {

          addConnection(from, to);
        }
      }
    }

    let tempLine = null;
    interact('.out-port').draggable({
      listeners: {
        start(event) {
          event.target.classList.add('port-hover');
          tempLine = new LeaderLine(event.target, { x: event.clientX, y: event.clientY }, {
            color: 'cyan',
            path: 'fluid',
            startPlug: 'square',
            endPlug: 'arrow'
          });
        },
        move(event) {
          if (tempLine) tempLine.setOptions({ end: { x: event.clientX, y: event.clientY } });
        },
        end(event) {
          event.target.classList.remove('port-hover');
          if (tempLine) {
            tempLine.remove();
            tempLine = null;
          }
        }
      }
    });

    interact('.in-port').dropzone({
      ondragenter(event) {
        event.target.classList.add('port-hover');
      },
      ondragleave(event) {
        event.target.classList.remove('port-hover');
      },
      ondrop(event) {
        event.target.classList.remove('port-hover');
        if (tempLine) {
          tempLine.remove();
          tempLine = null;
        }
        const from = event.relatedTarget;
        const to = event.target;
        addConnection(from, to);
      }
    });

    const dragOptions = {

      listeners: {
        move(event) {
          const target = event.target;
          const x = (parseFloat(target.dataset.x) || 0) + event.dx;
          const y = (parseFloat(target.dataset.y) || 0) + event.dy;
          target.style.transform = `translate(${x}px, ${y}px)`;
          target.dataset.x = x;
          target.dataset.y = y;

          connections.forEach(c => { c.line.position(); if (c.updateHandle) c.updateHandle(); });

        }
      }
    };

    interact('.card').draggable(dragOptions);

    // Pan and zoom functionality
    const state = { x: 0, y: 0, scale: 1 };
    let panning = false;
    let startX = 0, startY = 0;

    function updateTransform() {
      canvas.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale})`;
      connections.forEach(c => { c.line.position(); if (c.updateHandle) c.updateHandle(); });
    }

    workspace.addEventListener('mousedown', e => {
      if (e.target === workspace) {
        panning = true;
        startX = e.clientX;
        startY = e.clientY;
      }
    });
    window.addEventListener('mousemove', e => {
      if (panning) {
        state.x += e.clientX - startX;
        state.y += e.clientY - startY;
        startX = e.clientX;
        startY = e.clientY;
        updateTransform();
      }
    });
    window.addEventListener('mouseup', () => { panning = false; });

    workspace.addEventListener('wheel', e => {
      e.preventDefault();
      const delta = e.deltaY < 0 ? 0.1 : -0.1;
      state.scale = Math.min(2, Math.max(0.5, state.scale + delta));
      updateTransform();
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      state.x = 0; state.y = 0; state.scale = 1; updateTransform();
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      connections.slice().forEach(removeConnection);
    });

  </script>
</body>
</html>
