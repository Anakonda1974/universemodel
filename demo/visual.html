<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Universe Model Visual</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/leader-line@1.0.7/leader-line.min.js"></script>
  <script src="https://unpkg.com/interactjs/dist/interact.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }
    #workspace {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }
    #canvas {
      position: absolute;
      inset: 0;
      transform-origin: 0 0;
    }
    .bg-grid {
      background-image:
        linear-gradient(#e5e7eb 1px, transparent 1px),
        linear-gradient(90deg, #e5e7eb 1px, transparent 1px);
      background-size: 40px 40px;
    }
    .card {}
    .window {
      border: 1px solid #cbd5e1;
      border-radius: 0.5rem;
      background: white;
      overflow: hidden;
      z-index: 1;
    }
    .titlebar {
      background: #1e293b;
      color: white;
      padding: 0.25rem 0.5rem;
      cursor: move;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .titlebar .close-btn { color: #f87171; }
    .titlebar .close-btn:hover { color: #b91c1c; }
    .window-body { padding: 0.5rem; }

    .row:nth-child(odd) { background: #eef2ff; }
    .row:nth-child(even) { background: #e0e7ff; }

    .port {
      width: 1rem;
      height: 1rem;
      cursor: pointer;
      transition: outline 0.1s ease-in-out;
    }
    .port-hover, .port:hover { outline: 2px solid #fbbf24; }
    .collapsed .row { position: absolute; opacity: 0; pointer-events: none; }
    .line-handle {
      width: 0.75rem;
      height: 0.75rem;
      background: #22c55e;
      border-radius: 9999px;
      position: absolute;
      cursor: pointer;
      opacity: 0.8;
      pointer-events: auto;
    }

    .line-label {
      position: absolute;
      font-size: 0.75rem;
      background: rgba(0,0,0,0.6);
      padding: 0 0.25rem;
      border-radius: 0.25rem;
      pointer-events: none;
      white-space: nowrap;
    }

    /* Visual hint when dragging cards */
    .dragging {
      box-shadow: 0 0 0 4px #60a5fa;
    }

    /* Highlight potential drop targets when wiring */
    .port-target {
      outline: 2px dashed #94a3b8;
    }


    /* Selected cards */
    .selected {
      outline: 2px solid #10b981;
    }

    /* Simple context menu */
    #contextMenu {
      min-width: 8rem;
    }


  </style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div id="toolbar" class="absolute z-10 top-2 left-2 space-x-2">
    <label class="text-sm">Snap
      <input id="snapInput" type="number" value="20" min="1" class="ml-1 w-16 border border-gray-300 rounded px-1" />
    </label>
    <button id="resetBtn" class="bg-white border border-gray-300 px-2 py-1 rounded shadow text-sm hover:bg-gray-100">Reset view</button>
    <button id="clearBtn" class="bg-white border border-gray-300 px-2 py-1 rounded shadow text-sm hover:bg-gray-100">Clear connections</button>
  </div>
  <div id="workspace" class="bg-grid">
    <div id="canvas"></div>
  </div>
  <div id="contextMenu" class="absolute bg-white border border-gray-300 rounded shadow text-sm hidden z-20"></div>

  <script type="module">
    import { SeedManager } from '../dist/SeedManager.js';
    import { PropertyGraph } from '../dist/PropertyGraph.js';
    import { ProceduralEntity } from '../dist/ProceduralEntity.js';
    import { createPlanetDefinitions } from '../dist/PlanetDefinitions.js';

    const seedManager = new SeedManager('DemoSeed42');
    const baseDefinitions = createPlanetDefinitions();
    let graph = new PropertyGraph(JSON.parse(JSON.stringify(baseDefinitions)));
    const planet = new ProceduralEntity('Planet-X', ['MilkyWay','System-4','Planet-X'], seedManager, graph);

    let groups = planet.generateGrouped();
    let trace = planet.generateTrace();
    const workspace = document.getElementById('workspace');
    const canvas = document.getElementById('canvas');
    const snapInput = document.getElementById('snapInput');
    let snap = parseInt(snapInput.value) || 1;
    snapInput.addEventListener('change', () => {
      snap = parseInt(snapInput.value) || 1;
    });
    const snapCoord = v => Math.round(v / snap) * snap;

    const allPorts = new Map();
    const cards = [];

    let left = 20, top = 20;
    for (const [group, props] of Object.entries(groups)) {
      const card = createWindowCard(group, props, { x: left, y: top });
      top += 30;
      left += 220;
      canvas.appendChild(card);
      const rows = card.querySelectorAll('.row');
      rows.forEach(r => r.dataset.top = r.offsetTop);
      cards.push(card);
    }

    const connections = [];
    const undoStack = [];
    const redoStack = [];

    function buildGraph() {
      const defs = baseDefinitions
        .filter(def => document.getElementById('out-' + def.id))
        .map(def => ({ ...def, inputs: [] }));
      const map = {};
      defs.forEach(d => (map[d.id] = d));
      connections.forEach(c => {
        const from = c.from.dataset.prop;
        const to = c.to.dataset.prop;
        if (map[to]) {
          map[to].inputs.push(from);
        }
      });
      graph = new PropertyGraph(Object.values(map));
      planet.graph = graph;
    }

    function refreshValues() {
      groups = planet.generateGrouped();
      trace = planet.generateTrace();
      for (const card of cards) {
        const group = card.querySelector('.titlebar span').textContent;
        const props = groups[group] || {};
        for (const [key, value] of Object.entries(props)) {
          const row = card.querySelector(`.row[data-id="${key}"]`);
          if (!row) continue;
          const input = row.querySelector('.value-input');
          if (input) input.value = value;
          const inputs = trace[key]?.inputs || {};
          const inputStr = Object.entries(inputs).map(([k, v]) => `${k}: ${v}`).join(', ');
          const def = graph.getDefinition(key);
          const formula = def && def.compute ? def.compute.toString().replace(/\n/g, ' ') : '';
          row.title = formula + (inputStr ? ` | ${inputStr}` : '');
        }
      }
    }

    function recordAction(action) {
      undoStack.push(action);
      redoStack.length = 0;
    }

    function undo() {
      const action = undoStack.pop();
      if (!action) return;
      if (action.type === 'add') {
        const conn = connections.find(c => c.from.id === action.fromId && c.to.id === action.toId);
        if (conn) removeConnection(conn, true);
      } else if (action.type === 'remove') {
        const from = document.getElementById(action.fromId);
        const to = document.getElementById(action.toId);
        if (from && to) addConnection(from, to, action.points, true);
      }
      redoStack.push(action);
    }

    function redo() {
      const action = redoStack.pop();
      if (!action) return;
      if (action.type === 'add') {
        const from = document.getElementById(action.fromId);
        const to = document.getElementById(action.toId);
        if (from && to) addConnection(from, to, action.points, true);
      } else if (action.type === 'remove') {
        const conn = connections.find(c => c.from.id === action.fromId && c.to.id === action.toId);
        if (conn) removeConnection(conn, true);
      }
      undoStack.push(action);
    }

    const selectedCards = new Set();

    const contextMenu = document.getElementById('contextMenu');

    function hideContextMenu() {
      contextMenu.classList.add('hidden');
    }

    function showContextMenu(e, items) {
      contextMenu.innerHTML = '';
      items.forEach(item => {
        const div = document.createElement('div');
        div.textContent = item.label;
        div.className = 'px-2 py-1 hover:bg-gray-100 cursor-pointer';
        div.addEventListener('click', () => { item.action(); hideContextMenu(); });
        contextMenu.appendChild(div);
      });
      contextMenu.style.left = e.clientX + 'px';
      contextMenu.style.top = e.clientY + 'px';
      contextMenu.classList.remove('hidden');
    }

    window.addEventListener('click', hideContextMenu);
    window.addEventListener('contextmenu', e => {
      if (!contextMenu.contains(e.target)) hideContextMenu();
    });

    function clearSelection() {
      selectedCards.forEach(c => c.classList.remove('selected'));
      selectedCards.clear();
    }

    function toggleSelection(card) {
      if (selectedCards.has(card)) {
        card.classList.remove('selected');
        selectedCards.delete(card);
      } else {
        card.classList.add('selected');
        selectedCards.add(card);
      }
    }

    function selectSingle(card) {
      if (selectedCards.size === 1 && selectedCards.has(card)) return;
      clearSelection();
      card.classList.add('selected');
      selectedCards.add(card);
    }

    function removeConnection(conn, skipHistory = false) {
      conn.line.remove();

      if (conn.anchors) {
        conn.anchors.forEach(a => a.handle.remove());
      } else if (conn.handle) {
        conn.handle.remove();
      }
      if (conn.label) conn.label.remove();

      connections.splice(connections.indexOf(conn), 1);
      if (!skipHistory) {
        const points = conn.anchors ? conn.anchors.map(a => ({ x: a.pos.x, y: a.pos.y })) : [];
        recordAction({ type: 'remove', fromId: conn.from.id, toId: conn.to.id, points });
      }
      buildGraph();
      refreshValues();
    }

  function removeCard(card) {
    const ports = card.querySelectorAll('.port');
    ports.forEach(p => {
      connections.slice().forEach(c => {
        if (c.from === p || c.to === p) removeConnection(c);
      });
    });
    card.remove();
    buildGraph();
    refreshValues();
  }

  function createWindowCard(group, props, opts = {}) {
    const { x = 0, y = 0, width = 200, closable = true, collapsible = true, draggable = true } = opts;
    const card = document.createElement('div');
    card.className = 'card window absolute shadow';
    card.style.left = x + 'px';
    card.style.top = y + 'px';
    card.style.width = width + 'px';
    card.dataset.x = 0;
    card.dataset.y = 0;
    card.dataset.draggable = draggable;

    const header = document.createElement('div');
    header.className = 'titlebar';
    const titleEl = document.createElement('span');
    titleEl.textContent = group;
    header.appendChild(titleEl);
    if (closable) {
      const closeBtn = document.createElement('button');
      closeBtn.textContent = '×';
      closeBtn.className = 'close-btn';
      closeBtn.addEventListener('click', () => removeCard(card));
      header.appendChild(closeBtn);
    }

    header.addEventListener('mousedown', e => {
      if (e.shiftKey) {
        toggleSelection(card);
      } else {
        selectSingle(card);
      }
    });

    card.addEventListener('contextmenu', e => {
      e.preventDefault();
      selectSingle(card);
      showContextMenu(e, [
        { label: 'Delete card', action: () => removeCard(card) },
        { label: 'Clear connections', action: () => {
            card.querySelectorAll('.port').forEach(p => {
              connections.slice().forEach(c => {
                if (c.from === p || c.to === p) removeConnection(c);
              });
            });
          } }
      ]);
    });

    const body = document.createElement('div');
    body.className = 'window-body space-y-1';

    header.addEventListener('dblclick', () => {
      if (!collapsible) return;
      card.classList.toggle('collapsed');
      const collapsed = card.classList.contains('collapsed');
      const rows = body.querySelectorAll('.row');
      rows.forEach(r => {
        if (collapsed) {
          r.style.position = 'absolute';
          r.style.top = r.dataset.top + 'px';
          r.style.opacity = '0';
          r.style.pointerEvents = 'none';
        } else {
          r.style.position = '';
          r.style.top = '';
          r.style.opacity = '';
          r.style.pointerEvents = '';
        }
      });
      connections.forEach(c => { c.line.position(); if (c.updatePositions) c.updatePositions(); });
    });

    card.appendChild(header);

    for (const [key, value] of Object.entries(props)) {
      const row = document.createElement('div');
      row.className = 'row flex items-center text-sm mb-1 space-x-1 px-1 overflow-hidden';
      row.dataset.id = key;

      const inPort = document.createElement('div');
      inPort.className = 'port bg-red-300 rounded-full border border-red-400 in-port';
      inPort.id = `in-${key}`;
      inPort.dataset.prop = key;
      row.appendChild(inPort);

      const label = document.createElement('span');
      label.className = 'truncate flex-1';
      label.textContent = key + ':';
      row.appendChild(label);

      const valueInput = document.createElement('input');
      valueInput.type = 'text';
      valueInput.value = value;
      valueInput.className = 'value-input bg-gray-100 border border-gray-300 rounded px-1 text-gray-900 w-20';
      row.appendChild(valueInput);

      const outPort = document.createElement('div');
      outPort.className = 'port bg-blue-300 rounded-full border border-blue-400 out-port';
      outPort.id = `out-${key}`;
      outPort.dataset.prop = key;

      row.appendChild(outPort);

      const inputs = trace[key]?.inputs || {};
      const inputStr = Object.entries(inputs).map(([k, v]) => `${k}: ${v}`).join(', ');
      const def = graph.getDefinition(key);
      const formula = def && def.compute ? def.compute.toString().replace(/\n/g, ' ') : '';
      row.title = formula + (inputStr ? ` | ${inputStr}` : '');

      allPorts.set(outPort.id, outPort);
      allPorts.set(inPort.id, inPort);
      body.appendChild(row);
    }

    card.appendChild(body);
    return card;
  }


    function addConnection(from, to, points = [], skipHistory = false) {
      const fromId = from.dataset.prop;
      const toId = to.dataset.prop;
      if (!fromId || !toId) return;
      if (fromId === toId) {
        alert('Cannot connect a property to itself');
        return;
      }

      if (connections.some(c => c.from === from && c.to === to)) {
        return; // duplicate connection
      }

      const graph = {};
      connections.forEach(c => {
        const a = c.from.dataset.prop;
        const b = c.to.dataset.prop;
        if (!graph[a]) graph[a] = new Set();
        graph[a].add(b);
      });
      if (!graph[fromId]) graph[fromId] = new Set();
      graph[fromId].add(toId);

      function reachesStart(node, visited = new Set()) {
        if (node === fromId) return true;
        if (visited.has(node)) return false;
        visited.add(node);
        const next = graph[node];
        if (!next) return false;
        for (const n of next) {
          if (reachesStart(n, visited)) return true;
        }
        return false;
      }

      if (reachesStart(toId)) {
        alert('Invalid connection: circular dependency detected');
        return;
      }

      const line = new LeaderLine(from, to, {
        color: 'cyan',
        path: 'grid',
        startSocket: 'right',
        endSocket: 'left',
        startPlug: 'square',
        endPlug: 'arrow',
        zIndex: 0
      });

      const label = document.createElement('div');
      label.className = 'line-label';
      label.textContent = `${from.dataset.prop} → ${to.dataset.prop}`;
      label.addEventListener('dblclick', () => removeConnection(conn));
      workspace.appendChild(label);

      const conn = { line, from, to, label, anchors: [] };

      function addAnchorPoint(x, y) {
        if (!line.addPointAnchor || !LeaderLine.pointAnchor) return;
        const handle = document.createElement('div');
        handle.className = 'line-handle';
        workspace.appendChild(handle);
        const anchor = line.addPointAnchor(LeaderLine.pointAnchor({ element: handle }));
        const pos = { x: snapCoord(x), y: snapCoord(y) };
        const data = { anchor, handle, pos };
        conn.anchors.push(data);
        interact(handle).draggable({
          listeners: {
            move(ev) {
              data.pos.x = snapCoord(data.pos.x + ev.dx / state.scale);
              data.pos.y = snapCoord(data.pos.y + ev.dy / state.scale);
              updatePositions();
              line.position();
            }
          }
        });
        handle.addEventListener('dblclick', () => {
          if (line.removePointAnchor) {
            line.removePointAnchor(anchor);
          }
          const idx = conn.anchors.indexOf(data);
          if (idx !== -1) conn.anchors.splice(idx, 1);
          handle.remove();
          updatePositions();
          line.position();
        });
        updatePositions();
        line.position();
      }

      function setAnchorPoints(points) {
        if (line.removePointAnchor) {
          conn.anchors.forEach(a => line.removePointAnchor(a.anchor));
        }
        conn.anchors.forEach(a => a.handle.remove());
        conn.anchors = [];
        points.forEach(p => addAnchorPoint(snapCoord(p.x), snapCoord(p.y)));
      }

      function updatePositions() {
        const wsRect = workspace.getBoundingClientRect();
        let x, y;
        if (conn.anchors.length) {
          conn.anchors.forEach(a => {
            const ax = state.x + a.pos.x * state.scale;
            const ay = state.y + a.pos.y * state.scale;
            a.handle.style.left = `${ax - a.handle.offsetWidth / 2}px`;
            a.handle.style.top = `${ay - a.handle.offsetHeight / 2}px`;
          });
          const first = conn.anchors[0];
          x = state.x + first.pos.x * state.scale;
          y = state.y + first.pos.y * state.scale;
        } else {
          const s = from.getBoundingClientRect();
          const e = to.getBoundingClientRect();
          x = ((s.left + s.right) / 2 + (e.left + e.right) / 2) / 2 - wsRect.left;
          y = ((s.top + s.bottom) / 2 + (e.top + e.bottom) / 2) / 2 - wsRect.top;
        }

        label.style.left = `${x - label.offsetWidth / 2}px`;
        label.style.top = `${y - 20}px`;
      }

      conn.updatePositions = updatePositions;
      conn.addAnchorPoint = addAnchorPoint;
      conn.setAnchorPoints = setAnchorPoints;

      updatePositions();
      line.position();

      const lineElement = line.element || line.path || line.svg;
      if (lineElement && lineElement.style) {
        lineElement.style.pointerEvents = 'stroke';
        lineElement.addEventListener('dblclick', e => {
          const wsRect = workspace.getBoundingClientRect();
          const pos = {
            x: (e.clientX - wsRect.left - state.x) / state.scale,
            y: (e.clientY - wsRect.top - state.y) / state.scale
          };
          addAnchorPoint(snapCoord(pos.x), snapCoord(pos.y));
        });
      }

      if (points.length) setAnchorPoints(points);

      connections.push(conn);
      if (!skipHistory) {
        const pts = conn.anchors.map(a => ({ x: a.pos.x, y: a.pos.y }));
        recordAction({ type: 'add', fromId: from.id, toId: to.id, points: pts });
      }
      buildGraph();
      refreshValues();
      return conn;
    }


    for (const def of graph.getDefinitions()) {
      const deps = def.inputs || [];
      for (const dep of deps) {
        const from = document.getElementById('out-' + dep);
        const to = document.getElementById('in-' + def.id);
        if (from && to) {
          addConnection(from, to, [], true);
        }
      }
    }

    buildGraph();
    refreshValues();

    let tempLine = null;
    interact('.out-port').draggable({
      listeners: {
        start(event) {
          event.target.classList.add('port-hover');
          document.querySelectorAll('.in-port').forEach(p => p.classList.add('port-target'));
          tempLine = new LeaderLine(
            event.target,
            LeaderLine.pointAnchor({ x: event.clientX, y: event.clientY }),
            {
            color: 'cyan',
            path: 'grid',
            startSocket: 'right',
            endSocket: 'left',
            startPlug: 'square',
            endPlug: 'arrow'
            }
          );
        },
        move(event) {
          if (tempLine) {
            tempLine.setOptions({
              end: LeaderLine.pointAnchor({ x: event.clientX, y: event.clientY })
            });
          }
        },
        end(event) {
          event.target.classList.remove('port-hover');
          document.querySelectorAll('.in-port').forEach(p => p.classList.remove('port-target'));
          if (tempLine) {
            tempLine.remove();
            tempLine = null;
          }
        }
      }
    });

    interact('.in-port').dropzone({
      ondragenter(event) {
        event.target.classList.add('port-hover');
      },
      ondragleave(event) {
        event.target.classList.remove('port-hover');
      },
      ondrop(event) {
        event.target.classList.remove('port-hover');
        if (tempLine) {
          tempLine.remove();
          tempLine = null;
        }
        const from = event.relatedTarget;
        const to = event.target;
        addConnection(from, to);
      }
    });

    const dragOptions = {

      listeners: {
        start(event) {

          if (!selectedCards.has(event.target)) selectSingle(event.target);
          selectedCards.forEach(c => c.classList.add('dragging'));

        },
        move(event) {
          selectedCards.forEach(card => {
            let x = (parseFloat(card.dataset.x) || 0) + event.dx;
            let y = (parseFloat(card.dataset.y) || 0) + event.dy;
            x = snapCoord(x);
            y = snapCoord(y);
            card.style.transform = `translate(${x}px, ${y}px)`;
            card.dataset.x = x;
            card.dataset.y = y;
          });

          connections.forEach(c => { c.line.position(); if (c.updatePositions) c.updatePositions(); });

        },
        end(event) {

          selectedCards.forEach(c => c.classList.remove('dragging'));

        }
      }
    };

    interact('.card[data-draggable="true"]').draggable(dragOptions);

    // Pan and zoom functionality
    const state = { x: 0, y: 0, scale: 1 };
    let panning = false;
    let startX = 0, startY = 0;

    function updateTransform() {
      canvas.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale})`;
      connections.forEach(c => { c.line.position(); if (c.updatePositions) c.updatePositions(); });
    }

    workspace.addEventListener('mousedown', e => {
      if (e.target === workspace) {
        panning = true;
        startX = e.clientX;
        startY = e.clientY;
      }
    });
    window.addEventListener('mousemove', e => {
      if (panning) {
        state.x += e.clientX - startX;
        state.y += e.clientY - startY;
        startX = e.clientX;
        startY = e.clientY;
        updateTransform();
      }
    });
    window.addEventListener('mouseup', () => { panning = false; });

    workspace.addEventListener('wheel', e => {
      e.preventDefault();
      const delta = e.deltaY < 0 ? 0.1 : -0.1;
      state.scale = Math.min(2, Math.max(0.5, state.scale + delta));
      updateTransform();
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      state.x = 0; state.y = 0; state.scale = 1; updateTransform();
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      connections.slice().forEach(removeConnection);
      buildGraph();
      refreshValues();
    });

    window.addEventListener('keydown', e => {
      if (e.ctrlKey && e.key === 'z') {
        e.preventDefault();
        undo();
      } else if (e.ctrlKey && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) {
        e.preventDefault();
        redo();
      }
    });

  </script>
</body>
</html>
