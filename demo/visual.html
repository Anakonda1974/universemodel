<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Universe Model Visual</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/leader-line@1.0.7/leader-line.min.js"></script>
  <script src="https://unpkg.com/interactjs/dist/interact.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }
    #workspace {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }
    #canvas {
      position: absolute;
      inset: 0;
      transform-origin: 0 0;
    }
    .bg-grid {
      background-image:
        linear-gradient(#e5e7eb 1px, transparent 1px),
        linear-gradient(90deg, #e5e7eb 1px, transparent 1px);
      background-size: 40px 40px;
    }
    .card {}
    .window {
      border: 1px solid #cbd5e1;
      border-radius: 0.5rem;
      background: white;
      overflow: hidden;
    }
    .titlebar {
      background: #1e293b;
      color: white;
      padding: 0.25rem 0.5rem;
      cursor: move;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .titlebar .close-btn { color: #f87171; }
    .titlebar .close-btn:hover { color: #b91c1c; }
    .window-body { padding: 0.5rem; }

    .row:nth-child(odd) { background: #eef2ff; }
    .row:nth-child(even) { background: #e0e7ff; }

    .port {
      width: 1rem;
      height: 1rem;
      cursor: pointer;
      transition: outline 0.1s ease-in-out;
    }
    .port-hover, .port:hover { outline: 2px solid #fbbf24; }
    .collapsed .row { position: absolute; opacity: 0; pointer-events: none; }
    .line-handle {
      width: 0.75rem;
      height: 0.75rem;
      background: #22c55e;
      border-radius: 9999px;
      position: absolute;
      cursor: pointer;
    }

    .line-label {
      position: absolute;
      font-size: 0.75rem;
      background: rgba(0,0,0,0.6);
      padding: 0 0.25rem;
      border-radius: 0.25rem;
      pointer-events: none;
      white-space: nowrap;
    }

  </style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div id="toolbar" class="absolute z-10 top-2 left-2 space-x-2">
    <button id="resetBtn" class="bg-white border border-gray-300 px-2 py-1 rounded shadow text-sm hover:bg-gray-100">Reset view</button>
    <button id="clearBtn" class="bg-white border border-gray-300 px-2 py-1 rounded shadow text-sm hover:bg-gray-100">Clear connections</button>
  </div>
  <div id="workspace" class="bg-grid">
    <div id="canvas"></div>
  </div>

  <script type="module">
    import { SeedManager } from '../dist/SeedManager.js';
    import { PropertyGraph } from '../dist/PropertyGraph.js';
    import { ProceduralEntity } from '../dist/ProceduralEntity.js';
    import { createPlanetDefinitions } from '../dist/PlanetDefinitions.js';

    const seedManager = new SeedManager('DemoSeed42');
    const graph = new PropertyGraph(createPlanetDefinitions());
    const planet = new ProceduralEntity('Planet-X', ['MilkyWay','System-4','Planet-X'], seedManager, graph);

    const groups = planet.generateGrouped();
    const workspace = document.getElementById('workspace');
    const canvas = document.getElementById('canvas');

    const allPorts = new Map();
    const cards = [];

    let left = 20, top = 20;
    for (const [group, props] of Object.entries(groups)) {
      const card = createWindowCard(group, props, { x: left, y: top });
      top += 30;
      left += 220;
      canvas.appendChild(card);
      const rows = card.querySelectorAll('.row');
      rows.forEach(r => r.dataset.top = r.offsetTop);
      cards.push(card);
    }

    const connections = [];

    function removeConnection(conn) {
      conn.line.remove();

      conn.handle.remove();
      if (conn.label) conn.label.remove();

      connections.splice(connections.indexOf(conn), 1);
    }

  function removeCard(card) {
    const ports = card.querySelectorAll('.port');
    ports.forEach(p => {
      connections.slice().forEach(c => {
        if (c.from === p || c.to === p) removeConnection(c);
      });
    });
    card.remove();
  }

  function createWindowCard(group, props, opts = {}) {
    const { x = 0, y = 0, width = 200, closable = true, collapsible = true, draggable = true } = opts;
    const card = document.createElement('div');
    card.className = 'card window absolute shadow';
    card.style.left = x + 'px';
    card.style.top = y + 'px';
    card.style.width = width + 'px';
    card.dataset.x = 0;
    card.dataset.y = 0;
    card.dataset.draggable = draggable;

    const header = document.createElement('div');
    header.className = 'titlebar';
    const titleEl = document.createElement('span');
    titleEl.textContent = group;
    header.appendChild(titleEl);
    if (closable) {
      const closeBtn = document.createElement('button');
      closeBtn.textContent = '×';
      closeBtn.className = 'close-btn';
      closeBtn.addEventListener('click', () => removeCard(card));
      header.appendChild(closeBtn);
    }

    const body = document.createElement('div');
    body.className = 'window-body space-y-1';

    header.addEventListener('dblclick', () => {
      if (!collapsible) return;
      card.classList.toggle('collapsed');
      const collapsed = card.classList.contains('collapsed');
      const rows = body.querySelectorAll('.row');
      rows.forEach(r => {
        if (collapsed) {
          r.style.position = 'absolute';
          r.style.top = r.dataset.top + 'px';
          r.style.opacity = '0';
          r.style.pointerEvents = 'none';
        } else {
          r.style.position = '';
          r.style.top = '';
          r.style.opacity = '';
          r.style.pointerEvents = '';
        }
      });
      connections.forEach(c => { c.line.position(); if (c.updateHandle) c.updateHandle(); });
    });

    card.appendChild(header);

    for (const [key, value] of Object.entries(props)) {
      const row = document.createElement('div');
      row.className = 'row flex items-center text-sm mb-1 space-x-1 px-1';
      row.dataset.id = key;

      const inPort = document.createElement('div');
      inPort.className = 'port bg-red-300 rounded-full border border-red-400 in-port';
      inPort.id = `in-${key}`;
      inPort.dataset.prop = key;
      row.appendChild(inPort);

      const label = document.createElement('span');
      label.textContent = key + ':';
      row.appendChild(label);

      const valueInput = document.createElement('input');
      valueInput.type = 'text';
      valueInput.value = value;
      valueInput.className = 'value-input bg-gray-100 border border-gray-300 rounded px-1 text-gray-900 w-20';
      row.appendChild(valueInput);

      const outPort = document.createElement('div');
      outPort.className = 'port bg-blue-300 rounded-full border border-blue-400 out-port';
      outPort.id = `out-${key}`;
      outPort.dataset.prop = key;

      row.appendChild(outPort);

      allPorts.set(outPort.id, outPort);
      allPorts.set(inPort.id, inPort);
      body.appendChild(row);
    }

    card.appendChild(body);
    return card;
  }


    function addConnection(from, to) {
      const line = new LeaderLine(from, to, {
        color: 'cyan',
        path: 'fluid',
        startPlug: 'square',
        endPlug: 'arrow'
      });

      const handle = document.createElement('div');
      handle.className = 'line-handle';
      workspace.appendChild(handle);

      const label = document.createElement('div');
      label.className = 'line-label';
      label.textContent = `${from.dataset.prop} → ${to.dataset.prop}`;
      workspace.appendChild(label);

      const conn = { line, from, to, handle, label, anchor: null, anchorPos: null };

      function updateHandle() {
        const wsRect = workspace.getBoundingClientRect();
        let x, y;
        if (conn.anchorPos) {
          x = state.x + conn.anchorPos.x * state.scale;
          y = state.y + conn.anchorPos.y * state.scale;
        } else {
          const s = from.getBoundingClientRect();
          const e = to.getBoundingClientRect();
          x = ((s.left + s.right) / 2 + (e.left + e.right) / 2) / 2 - wsRect.left;
          y = ((s.top + s.bottom) / 2 + (e.top + e.bottom) / 2) / 2 - wsRect.top;
        }
        handle.style.left = `${x - handle.offsetWidth / 2}px`;
        handle.style.top = `${y - handle.offsetHeight / 2}px`;

        label.style.left = `${x - label.offsetWidth / 2}px`;
        label.style.top = `${y - 20}px`;
      }

      conn.updateHandle = updateHandle;
      updateHandle();
      line.position();

      const lineElement = line.element || line.path || line.svg;
      if (lineElement && lineElement.style) {
        lineElement.style.pointerEvents = 'stroke';
        lineElement.addEventListener('dblclick', e => {
          const wsRect = workspace.getBoundingClientRect();
          conn.anchorPos = {
            x: (e.clientX - wsRect.left - state.x) / state.scale,
            y: (e.clientY - wsRect.top - state.y) / state.scale
          };
          if (conn.anchor && line.removePointAnchor) {
            line.removePointAnchor(conn.anchor);
          }
          if (line.addPointAnchor && LeaderLine.pointAnchor) {
            conn.anchor = line.addPointAnchor(LeaderLine.pointAnchor({ element: handle }));
          }
          updateHandle();
          line.position();
        });
      }

      handle.addEventListener('dblclick', () => removeConnection(conn));

      connections.push(conn);
      return conn;
    }


    for (const def of graph.getDefinitions()) {
      const deps = def.inputs || [];
      for (const dep of deps) {
        const from = document.getElementById('out-' + dep);
        const to = document.getElementById('in-' + def.id);
        if (from && to) {

          addConnection(from, to);
        }
      }
    }

    let tempLine = null;
    interact('.out-port').draggable({
      listeners: {
        start(event) {
          event.target.classList.add('port-hover');
          tempLine = new LeaderLine(
            event.target,
            LeaderLine.pointAnchor({ x: event.clientX, y: event.clientY }),
            {
            color: 'cyan',
            path: 'fluid',
            startPlug: 'square',
            endPlug: 'arrow'
            }
          );
        },
        move(event) {
          if (tempLine) {
            tempLine.setOptions({
              end: LeaderLine.pointAnchor({ x: event.clientX, y: event.clientY })
            });
          }
        },
        end(event) {
          event.target.classList.remove('port-hover');
          if (tempLine) {
            tempLine.remove();
            tempLine = null;
          }
        }
      }
    });

    interact('.in-port').dropzone({
      ondragenter(event) {
        event.target.classList.add('port-hover');
      },
      ondragleave(event) {
        event.target.classList.remove('port-hover');
      },
      ondrop(event) {
        event.target.classList.remove('port-hover');
        if (tempLine) {
          tempLine.remove();
          tempLine = null;
        }
        const from = event.relatedTarget;
        const to = event.target;
        addConnection(from, to);
      }
    });

    const dragOptions = {

      listeners: {
        move(event) {
          const target = event.target;
          const x = (parseFloat(target.dataset.x) || 0) + event.dx;
          const y = (parseFloat(target.dataset.y) || 0) + event.dy;
          target.style.transform = `translate(${x}px, ${y}px)`;
          target.dataset.x = x;
          target.dataset.y = y;

          connections.forEach(c => { c.line.position(); if (c.updateHandle) c.updateHandle(); });

        }
      }
    };

    interact('.card[data-draggable="true"]').draggable(dragOptions);

    // Pan and zoom functionality
    const state = { x: 0, y: 0, scale: 1 };
    let panning = false;
    let startX = 0, startY = 0;

    function updateTransform() {
      canvas.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale})`;
      connections.forEach(c => { c.line.position(); if (c.updateHandle) c.updateHandle(); });
    }

    workspace.addEventListener('mousedown', e => {
      if (e.target === workspace) {
        panning = true;
        startX = e.clientX;
        startY = e.clientY;
      }
    });
    window.addEventListener('mousemove', e => {
      if (panning) {
        state.x += e.clientX - startX;
        state.y += e.clientY - startY;
        startX = e.clientX;
        startY = e.clientY;
        updateTransform();
      }
    });
    window.addEventListener('mouseup', () => { panning = false; });

    workspace.addEventListener('wheel', e => {
      e.preventDefault();
      const delta = e.deltaY < 0 ? 0.1 : -0.1;
      state.scale = Math.min(2, Math.max(0.5, state.scale + delta));
      updateTransform();
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      state.x = 0; state.y = 0; state.scale = 1; updateTransform();
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      connections.slice().forEach(removeConnection);
    });

  </script>
</body>
</html>
